
// ADVANCED
#define Enable_NPR 0  // Toon Style Array
#define Eyeball_Offset 1  // Recommended for DIVA Heads
#define SSS_Intensity 0.5

//==============================//
//           IBL(s) : 
//=============================//
#define _IBL "IBL(s)/IBL.dds"   // Diffuse
#define _IBL1 "IBL(s)/1_.dds"   // Specular
#define _IBL2 "IBL(s)/2_.dds"   // Specular Rough
#define _IBL3 "IBL(s)/3_.dds"   // Specular Shadowed
#define _IBL4 "IBL(s)/4_.dds"   // Specular Shadowed Rough
//================================================================//

float4   Camera_Position    : POSITION  < string Object = "Camera"; >;
float4   Camera_Direction  : DIRECTION  < string Object = "Camera"; >;
float4   Light_Direction  : DIRECTION  < string Object = "Light"; >;

//float4x4 g_self_shadow_receivers : WORLDVIEWPROJECTION < string Object = "Light"; >;

float2 ViewportSize : VIEWPORTPIXELSIZE;
static const float2 ViewportOffset = float2(0.5,0.5)/ViewportSize;
static const float4 g_framebuffer_size = float4(1 + ViewportOffset.xyxy);

#define SF_X "ShaderFarc.x"
bool SF_Valid : CONTROLOBJECT < string name = SF_X; >;

#define Controller "#ShaderFarc_Controller.pmx"
#define IBLDirection "IBL Direction"

float4x4 IBL_Controller : CONTROLOBJECT < string name = Controller; string item = IBLDirection ; >;

static float3 IBL_Dir = IBL_Controller._31_32_33;
//static float3 IBL_Dir = IBL_Controller._31_32_33;

float3x3 Rotation(float3 in_axis, float s, float c)
{	
	float3x3 in_m1;
    float c_1 = 1.0f - c;
    float3 axis = normalize(in_axis);
    float3 axis_s = axis * s;

    float3 temp;
    temp = axis * axis.x * c_1;
    in_m1[0].x = temp.x + c;
    in_m1[1].x = temp.y - axis_s.z;
    in_m1[2].x = temp.z + axis_s.y;
    temp = axis * axis.y * c_1;
    in_m1[0].y = temp.x + axis_s.z;
    in_m1[1].y = temp.y + c;
    in_m1[2].y = temp.z - axis_s.x;
    temp = axis * axis.z * c_1;
    in_m1[0].z = temp.x - axis_s.y;
    in_m1[1].z = temp.y + axis_s.x;
    in_m1[2].z = temp.z + c;
	return in_m1;
}

float3x3 NormalTransform(float3 Light_Direction, float3 IBL_dir)
{	
	float3x3 CUBETransform;;
	float leng = length(IBL_dir.xyz);
    if (leng >= 0.00000f) {
        float3 ibl_direction = IBL_dir.xyz * (1.0f / leng);

		float3 ibl_position = Light_Direction * float3(1, 1, -1);
        leng = length(ibl_position.xyz);
        if (leng >= 0.00000f) {
            float3 position = ibl_position * (1.0f / leng);
		
			float3 axis = cross(ibl_direction, position);
            leng = length(axis.xyz);

            float v52 = dot(ibl_direction, position);
            float angle = abs(atan2(leng, v52));
			
			if (angle >= 0.00000f && angle <= 3.131592653589793f) {
                if (leng != 0.0f)
                    axis *= 1.0f / leng;
				
			CUBETransform = Rotation(axis, sin(-angle), cos(-angle));
	
	float3 RotationAngles = radians(float3(-45, -45, 0));
	float3x3 rotationX = {
    1, 0, 0,
    0, cos(RotationAngles.x), sin(RotationAngles.x),
    0, -sin(RotationAngles.x), cos(RotationAngles.x)};

	float3x3 rotationY = {
    cos(RotationAngles.y), 0, -sin(RotationAngles.y),
    0, 1, 0,
    sin(RotationAngles.y), 0, cos(RotationAngles.y)};

	float3x3 rotationZ = {
    cos(RotationAngles.z), sin(RotationAngles.z), 0,
    -sin(RotationAngles.z), cos(RotationAngles.z), 0,
    0, 0, 1};

	CUBETransform = mul(CUBETransform, rotationX);
	CUBETransform = mul(CUBETransform, rotationY);
	CUBETransform = mul(CUBETransform, rotationZ);
	
	float3x3 Scale = {
	1.00, 0.00, 0.00,
	0.00, 1.00, 0.00,
	0.00, 0.00, 1.00};
	
	CUBETransform = mul(CUBETransform, Scale);	} } }
	return CUBETransform;
}

static float3x3 g_normal_tangent_transforms = NormalTransform(Light_Direction, -IBL_Dir);



// 座法変換行列

float4x4 LightWorldViewProjMatrix : WORLDVIEWPROJECTION < string Object = "Light"; >;

float4x4 g_transforms : WORLDVIEWPROJECTION;
float4x4 g_worlds     : WORLD;
float4x4 g_worlds_invtrans : WORLDINVERSETRANSPOSE;
float4x4 g_worldview        : WORLDVIEW;
float4x4 g_worldview_inverse : WORLDVIEWINVERSE;
float4x4 g_joint : VIEW;
float4x4 g_joint_inverse : VIEWINVERSE;
    //mat2x4 g_texcoord_transforms[2];


// マテリアル色
float4   MaterialDiffuse   : DIFFUSE  < string Object = "Geometry"; >;
float4   MaterialAmbient   : AMBIENT  < string Object = "Geometry"; >;
float4   MaterialEmmisive  : EMISSIVE < string Object = "Geometry"; >;
float4   MaterialSpecular  : SPECULAR < string Object = "Geometry"; >;
float    SpecularPower     : SPECULARPOWER < string Object = "Geometry"; >;
float4   MaterialToon      : TOONCOLOR;
// ライト色
float4   LightDiffuse      : DIFFUSE   < string Object = "Light"; >;
float4   LightAmbient      : AMBIENT   < string Object = "Light"; >;
float4   LightSpecular     : SPECULAR  < string Object = "Light"; >;
static float4 DiffuseColor  = MaterialDiffuse  * float4(LightDiffuse);
static float4 AmbientColor  = MaterialAmbient  * LightAmbient + MaterialEmmisive;
static float4 SpecularColor = MaterialSpecular * LightSpecular;

float Tr : CONTROLOBJECT <string name="(Adjuster.pmd)"; string item="合成弱め";>;
float BrightPlus : CONTROLOBJECT <string name="(self)"; string item="isekai";>;

bool use_texture;  //テクスチャの有無
bool use_toon;     //トゥーンの有無

bool     parthf;   // パースペクティブフラグ
bool     transp;   // 半透明フラグ
#define SKII1    1500
#define SKII2    8000
#define Toon     3

static float4 g_material = float4(1, 1, 1, clamp(MaterialDiffuse.w, 0, 1));

#define NORMAL Normal
#define SPECULAR SpecularMap
#define TRANSPARENCY Transparency
#define TRANSLUCENCY Translucency
#define ENV_MAP OverrideIBL

#define BONE_MAT_DEF 0
#define MORPH_DEF 0

#define SPECULAR_IBL 1

#define SPECULAR_IBL_1 1
#define SPECULAR_IBL_2 0

#define SELF_SHADOW 1
#define FOG_1 0
#define FOG_2 0
#define ALPHA_TEST_DEF Punch_through
#define ANISO_1 0
#define ANISO_2 0
#define ANISO_3 0
#define SHADOW 0

#define CHARA_COLOR 1
#define TONE_CURVE 0

#define TEXTURE_COUNT_1 1
#define TEXTURE_COUNT_2 1

#define U18 0 //???

static float4 g_light_env_chara_diffuse = LightAmbient;
static float4 g_light_env_chara_ambient = LightDiffuse;
static float4 g_light_env_chara_specular = LightSpecular;

static float4 g_view_position = float4(Camera_Position.xyz, 0.00);
static float4 g_light_chara_dir = float4(-Light_Direction.xyz * float3(1, 1, -1), 0.00);

#ifdef PMX_Color
static float4 g_material_state_diffuse = MaterialDiffuse;
static float4 g_material_state_ambient = MaterialAmbient;
float4 g_material_state_emission = Emission;

#if SHADER_TYPE == 5
float4 g_material_state_shininess = float4(10.0f, 0.00, 0.00, 0.00);
#else
static float4 g_material_state_shininess = float4(max((SpecularPower - 16.0f)*(1.0f/112.0f), 0.0f), 0.00, 0.00, 0.00);
#endif

float4 PMX_Specular = Specular;
static float4 g_material_state_specular = float4((float4(MaterialSpecular.xyz, PMX_Specular.w) * LightAmbient).xyz, length(LightAmbient.xyz));

#if Fresnel > 8
    static float fresnel_i = 9.0f;
#else
    static float fresnel_i = 7.0f;
#endif

#if Phong_Shading == 1
static float line_light_f = (float)Line_light * (float)(1.0 / 9.0);
#else
static float line_light_f = 0.0f;
#endif
static float fresnel_f = (fresnel_i - 1.0f) * 0.12f * 0.82f;

static float4 g_fresnel_coefficients = float4(fresnel_f, 0.18f, line_light_f, 0.00f);

static float4 g_shininess = float4(max(SpecularPower, 1.0f), 0.00f, 0.00f, 0.00f);

#else
float4 g_material_state_diffuse = Diffuse;
float4 g_material_state_ambient = Ambient;
float4 g_material_state_emission = Emission;

#if SHADER_TYPE == 5
float4 g_material_state_shininess = float4(10.0f, 0.00, 0.00, 0.00);
#else
float4 g_material_state_shininess = float4(max((Shininess - 16.0f)*(1.0f/112.0f), 0.0f), 0.00, 0.00, 0.00);
#endif
static float4 g_material_state_specular = float4((Specular * LightAmbient).xyz, length(LightAmbient.xyz));

#if Fresnel > 8
    static float fresnel_i = 9.0f;
#else
    static float fresnel_i = 7.0f;
#endif

#if Phong_Shading == 1
static float line_light_f = (float)Line_light * (float)(1.0 / 9.0);
#else
static float line_light_f = 0.0f;
#endif
static float fresnel_f = (fresnel_i - 1.0f) * 0.12f * 0.82f;

static float4 g_fresnel_coefficients = float4(fresnel_f, 0.18f, line_light_f, 0.00f);

float4 g_shininess = float4(max(Shininess, 1.0f), 0.00f, 0.00f, 0.00f);
#endif
float4 g_intensity = float4(Intensity, 1.00, 0.00, 1.00);

float4 g_sss_param = float4(SSS_Intensity, 0.00, 0.00, 0.50);

    float4 field_0 = float4(5.0f, 5.0f, 0.5f, 0.5f);
    float4 field_10 = float4(2.5f, 2.5f, 0.5f, 0.5f);
    float field_20 = 1.0f;
    float field_24 = 1.45f;
    float field_28 = 0.02f;
    float field_2C = 0.85f;
    float3 field_30 = float3(1.0f, 1.2f, 0.45f);
    float3 field_3C = float3(1.0f, 1.2f, 0.25f);
    float3 field_48 = float3(0.5f, 0.6f, 0.4f);
    float field_54 = -0.2f;
    float3 field_58 = float3(1.0f, 1.0f, 1.0f);
	
    static const float field_64 = field_2C / field_28; ////////////////////////////
    static const float3 field_68 = float3(field_30 * field_28); ////////////////////////////
    static const float3 field_74 = float3(field_3C * field_28);
    static const float3 field_80 = float3(field_48 * field_28);
    static const float field_8C = field_54 * field_28; ////////////////////////////
    static const float3 field_90 = float3(field_58); ////////////////////////////
	float4 field_A0 = float4(0.0f, 0.0f, 0.0f, 0.0f);
	
    static const float4 g_ellipsoid_radius = float4(rcp(field_68 * field_68), (field_68 * field_68).z);
    static const float4 g_ellipsoid_scale = float4(field_68, 1.0f);
    static const float4 g_tex_model_param = float4(field_0);
    static const float4 g_tex_offset = float4(field_A0);
    static const float4 g_eb_radius = float4(rcp(field_90 * field_90), (field_90 * field_90).z);
    static const float4 g_eb_tex_model_param = float4(field_10);
	static const float v2 = (field_20 - field_24) / (field_20 + field_24);
    static const float4 g_fresnel = float4(1.0f - (v2 * v2), (v2 * v2), 0.0f, 0.0f);
	static const float v3 = (field_20 * field_20) / (field_24 * field_24);
    static const float4 g_refract1 = float4(v3, 1.0f - v3, field_20 / field_24, 0.0f);
	static const float v4 = (field_24 * field_24) / (field_20 * field_20);
    static const float4 g_refract2 = float4(v4, 1.0f - v4, field_24 / field_20, 0.0f);
    static const float4 g_iris_radius = float4(rcp(field_74 * field_74), -1.0f);
    static const float4 g_cornea_radius = float4(rcp(field_68 * field_68), -1.0f);
    static const float4 g_pupil_radius = float4(rcp(field_80 * field_80), -1.0f);
    static const float4 g_tex_scale = float4(rcp(field_0.xy * field_74.xy), field_64 * 1.442695f, field_8C);
	
float2 gl_FragCoord;

#if Aniso_Direction > 0
	#define ANISO 1
#endif

#if Aniso_Direction == 1
	#define ANISO_1 1
#else
	#define ANISO_1 0
#endif

#if Aniso_Direction == 2
	#define ANISO_2 1
#else
	#define ANISO_2 0
#endif

#if Aniso_Direction == 3
	#define ANISO_3 1
#else
	#define ANISO_3 0
#endif

#if Enable_NPR
	#define NPR 1
#endif
	
#include "- Shaders/#Include/+ HgShadow.fxh"

#if SHADER_TYPE == 0
	#include "- Shaders/item_blinn.fxsub"
#elif SHADER_TYPE == 1
	#include "- Shaders/skin_default.fxsub"
#elif SHADER_TYPE == 2
	#if NPR
		#include "- Shaders/cloth_npr1.fxsub"
	#elif ANISO == 1
		//#include "- Shaders/cloth_aniso.fxsub"
	#else
		#include "- Shaders/cloth_default.fxsub"
	#endif
#elif SHADER_TYPE == 3
	#include "- Shaders/tights.fxsub"
#elif SHADER_TYPE == 4
	#include "- Shaders/hair_default.fxsub"
#elif SHADER_TYPE == 5
	#include "- Shaders/glass_eye.fxsub"
#elif SHADER_TYPE == 6
	#include "- Shaders/sss_skin.fxsub"
#endif